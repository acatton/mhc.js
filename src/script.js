// Generated by CoffeeScript 1.9.0
(function() {
  var ASCII_LEN, ASCII_MASK, BASE_64, BYTE_LENGTH, HASHCASH_DEFAULT_BITS, HASHCASH_DEFAULT_RAND_LEN, HASHCASH_DEFAULT_VERSION, UTF8_BYTE_BITS, UTF8_BYTE_MASK, UTF8_EXTRA_BITS, UTF8_MAX_BIT_AMOUNT, arrayToHex, baseLog, hashcashDate, hashcashToString, headNullBitCount, intToBase64Char, randomBase64String, sha1Uint8Array, strToHexDigest, strToUint8Array, toResource, uint8ArrayFrom, uint8ArrayNullBitCount, utf8Encode,
    __hasProp = {}.hasOwnProperty;

  BYTE_LENGTH = 8;

  ASCII_LEN = 7;

  ASCII_MASK = (1 << ASCII_LEN) - 1;

  BASE_64 = 64;

  UTF8_MAX_BIT_AMOUNT = 31;

  UTF8_BYTE_BITS = 6;

  UTF8_BYTE_MASK = (1 << UTF8_BYTE_BITS) - 1;

  UTF8_EXTRA_BITS = 0x80;

  uint8ArrayFrom = function(arr) {
    var ret;
    ret = new Uint8Array(arr.length);
    ret.set(arr);
    return ret;
  };

  baseLog = function(n, base) {
    return (Math.log(n)) / (Math.log(base));
  };

  utf8Encode = function(val) {
    var bitsAmount, byteAmount, bytes, countBits, lastByteBitAmount, lastByteExtraBits;
    countBits = function(n) {
      return 1 + Math.floor(baseLog(n, 2));
    };
    bitsAmount = countBits(val);
    if (bitsAmount <= ASCII_LEN) {
      return [val];
    } else {
      if (bitsAmount > UTF8_MAX_BIT_AMOUNT) {
        throw new Error("UTF-8 doesn't support characters encoded on more than " + UTF8_MAX_BIT_AMOUNT + "bits");
      }
      byteAmount = 0;
      bytes = [];
      lastByteBitAmount = function() {
        return BYTE_LENGTH - 2 - byteAmount;
      };
      lastByteExtraBits = function() {
        var extraBits;
        extraBits = (1 << byteAmount) - 1;
        extraBits <<= 2;
        extraBits |= 0x2;
        extraBits <<= lastByteBitAmount();
        return extraBits;
      };
      while (countBits(val) > lastByteBitAmount()) {
        bytes.unshift((val & UTF8_BYTE_MASK) | UTF8_EXTRA_BITS);
        val >>= UTF8_BYTE_BITS;
        byteAmount++;
      }
      bytes.unshift(val | lastByteExtraBits());
      return bytes;
    }
  };

  strToUint8Array = function(str) {
    return uint8ArrayFrom(str.split('').reduce(function(accumulator, element) {
      return accumulator.concat(utf8Encode(element.charCodeAt(0)));
    }, []));
  };

  sha1Uint8Array = function(arr) {
    return (window.crypto.subtle.digest("SHA-1", arr.buffer)).then(function(result) {
      return new Uint8Array(result);
    });
  };

  arrayToHex = function(arr) {
    var reduce, toHex;
    toHex = function(i) {
      return i.toString(16);
    };
    reduce = function(arr, callback, initialValue) {
      var acc, i, _i, _ref;
      acc = initialValue;
      for (i = _i = 0, _ref = arr.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        acc = callback(acc, arr[i]);
      }
      return acc;
    };
    return reduce(arr, function(accumulator, element) {
      return accumulator + (element > 16 ? toHex(element) : "0" + toHex(element));
    }, "");
  };

  HASHCASH_DEFAULT_VERSION = 1;

  HASHCASH_DEFAULT_BITS = 20;

  HASHCASH_DEFAULT_RAND_LEN = 16;

  hashcashDate = function(d) {
    var toTwoNums;
    toTwoNums = function(n) {
      n = n % 100;
      if (n < 10) {
        return "0" + n;
      } else {
        return "" + n;
      }
    };
    return [d.getFullYear(), d.getMonth(), d.getHours(), d.getMinutes(), d.getSeconds()].reduce(function(accumulator, elem) {
      return accumulator + toTwoNums(elem);
    }, "");
  };

  hashcashToString = function(version, bits, date, resource, extension, rand, counter) {
    if (version == null) {
      version = HASHCASH_DEFAULT_VERSION;
    }
    if (bits == null) {
      bits = HASHCASH_DEFAULT_BITS;
    }
    if (date == null) {
      date = new Date();
    }
    date = typeof date === "string" ? date : hashcashDate(date);
    if (resource == null) {
      resource = "";
    }
    if (extension == null) {
      extension = "";
    }
    if (counter == null) {
      counter = "";
    }
    return [version, bits, date, resource, extension, rand, counter].join(':');
  };

  intToBase64Char = function(i) {
    var charOffset;
    charOffset = function(chr, offset) {
      return String.fromCharCode(chr.charCodeAt(0) + offset);
    };
    if ((0 <= i && i <= 25)) {
      return charOffset('A', i);
    } else if ((26 <= i && i <= 51)) {
      return charOffset('a', i - 26);
    } else if ((52 <= i && i <= 61)) {
      return charOffset('0', i - 52);
    } else if (i === 62) {
      return '+';
    } else if (i === 63) {
      return '/';
    } else {
      throw new Error("intToBase64Char is supposed to get an ingeter " + "between 0 and 63");
    }
  };

  randomBase64String = function(len) {
    var i;
    return ((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
        _results.push(intToBase64Char(0 | 63 * Math.random()));
      }
      return _results;
    })()).join('');
  };

  strToHexDigest = function(str) {
    return (sha1Uint8Array(strToUint8Array(str))).then(function(arr) {
      return arrayToHex(arr);
    });
  };

  toResource = function(val) {
    var arrayToResource, hashArray, hashKeyValue, hashObject, numberToResource, objectToResource, stringToResource;
    hashKeyValue = function(key, value) {
      return Promise.all([key, value].map(toResource)).then(function(resources) {
        return Promise.all(resources.map(strToHexDigest));
      }).then(function(digests) {
        return strToHexDigest(digests.join(''));
      });
    };
    hashArray = function(arr) {
      return Promise.all(arr.map(toResource)).then(function(resources) {
        return Promise.all(resources.map(strToHexDigest));
      }).then(function(hashes) {
        hashes.sort();
        return strToHexDigest(hashes.join(''));
      });
    };
    hashObject = function(obj) {
      var key, value;
      return Promise.all((function() {
        var _results;
        _results = [];
        for (key in obj) {
          if (!__hasProp.call(obj, key)) continue;
          value = obj[key];
          if (typeof value !== "function") {
            _results.push(hashKeyValue(key, value));
          }
        }
        return _results;
      })()).then(function(arr) {
        return hashArray(arr);
      });
    };
    stringToResource = function(str) {
      if (str.match(/:/)) {
        return strToHexDigest(str);
      } else {
        return new Promise(function(resolve, reject) {
          return resolve(str);
        });
      }
    };
    numberToResource = function(n) {
      return new Promise(function(resolve, reject) {
        return resolve("" + n);
      });
    };
    arrayToResource = function(arr) {
      return hashArray(arr);
    };
    objectToResource = function(obj) {
      return hashObject(obj);
    };
    if (typeof val === "string") {
      return stringToResource(val);
    } else if (typeof val === "number") {
      return numberToResource(val);
    } else if (val.isArray) {
      return arrayToResource(val);
    } else if (typeof val === "object") {
      return objectToResource(val);
    } else {
      throw new Error("toResource only supports strings, numbers and objects");
    }
  };

  window.Hashcash = (function() {
    function Hashcash(str) {
      var _ref;
      _ref = str.split(':'), this.version = _ref[0], this.bits = _ref[1], this.date = _ref[2], this.resource = _ref[3], this.extension = _ref[4], this.rand = _ref[5], this.counter = _ref[6];
      if (this.bits == null) {
        this.bits = HASHCASH_DEFAULT_BITS;
      }
      this.bits = this.bits | 0;
    }

    Hashcash.prototype.toString = function() {
      return hashcashToString(this.version, this.bits, this.date, this.resource, this.extension, this.rand, this.counter);
    };

    Hashcash.prototype.findSolution = function() {
      var hashcashFromCounter, hashcashStringOfCounter, incrementCounter, isValid, stringOfCounter;
      stringOfCounter = function(counter) {
        return (counter.map(intToBase64Char)).join('');
      };
      hashcashStringOfCounter = (function(_this) {
        return function(counter) {
          return hashcashToString(_this.version, _this.bits, _this.date, _this.resource, _this.extension, _this.rand, stringOfCounter(counter));
        };
      })(this);
      isValid = (function(_this) {
        return function(counter) {
          var str;
          str = hashcashStringOfCounter(counter);
          return (sha1Uint8Array(strToUint8Array(str))).then(function(result) {
            return (uint8ArrayNullBitCount(result)) >= _this.bits;
          });
        };
      })(this);
      incrementCounter = function(counter) {
        var i, val;
        for (i in counter) {
          val = counter[i];
          counter[i] = (val + 1) % BASE_64;
          if (counter[i] > 0) {
            return counter;
          }
        }
        counter.push(0);
        return counter;
      };
      hashcashFromCounter = function(counter) {
        return new Hashcash(hashcashStringOfCounter(counter));
      };
      return new Promise(function(resolve, reject) {
        var check, counter;
        counter = [0];
        check = function(counter) {
          return isValid(counter).then(function(counterIsValid) {
            if (counterIsValid) {
              return resolve(hashcashFromCounter(counter));
            } else {
              return check(incrementCounter(counter));
            }
          });
        };
        return check(counter);
      });
    };

    return Hashcash;

  })();

  window.Hashcash.fromResource = function(resource) {
    var rand;
    rand = randomBase64String(HASHCASH_DEFAULT_RAND_LEN);
    return new Hashcash(hashcashToString(null, null, null, resource, null, rand, null));
  };

  headNullBitCount = function(n, length) {
    if (n === 0) {
      return length;
    } else {
      return length - (1 + Math.floor(baseLog(n, 2)));
    }
  };

  uint8ArrayNullBitCount = function(arr) {
    var acc, i, value, _i, _ref;
    acc = 0;
    for (i = _i = 0, _ref = arr.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      value = arr[i];
      acc += headNullBitCount(value, BYTE_LENGTH);
      if (value > 0) {
        break;
      }
    }
    return acc;
  };

}).call(this);
